#!/usr/bin/python

import numpy as np
import math
import copy

from linesAPIs import *
from determineContigSegFromLines import *
from objAdjacencyMap import *

class squareCls:

   displayDelimiter = "SSSSSSSSSSSSSSSSSSSSS"

   def __init__(self, xMin, yMin, squareDim):
      self.squareDim = squareDim
      self.xMin = xMin
      self.xMax = self.xMin + self.squareDim
      self.yMin = yMin
      self.yMax = self.yMin + self.squareDim

      self.lineSegsInSquare = []

   def displaySquareData(self):
      print(squareCls.displayDelimiter)
      print("square dimension is " + str(self.squareDim))
      print("square XMIN is " + str(self.xMin))
      print("square XMAX is " + str(self.xMax))
      print("square YMIN is " + str(self.yMin))
      print("square YMAX is " + str(self.yMax))
      print("line segs in square is " + str(self.lineSegsInSquare))

   # define if a pt is in square
   #   by seeing if it is >= xMin / yMin
   #   and if it is < xMax / yMax
   # V2 - need to allow for pt to be ON xMax / yMax
   def checkIfPtIsInSquare(self, pt):
      return (pt[0] >= self.xMin and pt[0] <= self.xMax and pt[1] >= self.yMin and pt[1] <= self.yMax)

   def insertLineIdxIntoSquare(self, idx):
      if not idx in self.lineSegsInSquare:
         self.lineSegsInSquare.append(idx)

   def removeLineIdxFromSquare(self, idx):
      try:
         self.lineSegsInSquare.remove(idx)
      except:
         print("idx %s not found in square with xMin %s : yMin %s" % (idx, self.xMin, self.yMin))

   # return a tuple of the start pt and end pt
   def getLineThatFitsIntoSquare(self, line):
      if not self.checkIfPtIsInSquare(line.termPt1):
         print("start pt " + str(line.termPt1) + " does not belong in this square - exit")
         self.displaySquareData()
         return None

      retLine = copy.deepcopy(line)

      # need to check if end pt is in square
      if not self.checkIfPtIsInSquare(line.termPt2):
         # need to check which pt is the intersection
         # between the line and the border of the box
         # to do this - will calculate the following 4 eqns
         #  line.termPt1[0] + A1*line.unitVect[0] = xMin (of square)
         #  line.termPt1[0] + A2*line.unitVect[0] = xMax (of square)
         #  line.termPt1[1] + A3*line.unitVect[1] = yMin (of square)
         #  line.termPt1[1] + A4*line.unitVect[1] = yMax (of square)
         # exclude the equations where unitVect[0] or unitVect[1] is 0
         AMin = None

         borderPts = ((self.xMin, self.xMax), (self.yMin, self.yMax))
         for i in range(2):
            if math.fabs(line.unitVect[i]) > 0:
               for borderEntry in borderPts[i]:
                  ACandidate = (borderEntry - line.termPt1[i]) / line.unitVect[i]
                  if ACandidate > 0 and \
                     (not AMin or ACandidate < AMin):
                     AMin = ACandidate

         if not AMin:
            print("Unable to find valid AMin - exit")
            return None

         print("Calculating AMin to be " + str(AMin))
         retLine.setEndPt(line.termPt1 + AMin * line.unitVect)

      return retLine

#######################
### DESIGN NOTES ##
##
## 1) treat pt as belonging in Grid IF:
##    - pt is >= startPt of SQUARE AND < endPt of SQUARE ie. [startPt, endPt)
## 2) HOWEVER, condition above is broken IFF it is a start pt of a line ON a boundary
##     AND the line lies in the adjacent cell
##     eg. if pt is on XMin BUT the line lies on the cell to its left
##
#######################
class gridCls:

   displayDelimiter = "GGGGGGGGGGGGGGGGGGGGG"

   xPosVect = np.array([1,0])
   yPosVect = np.array([0,1])

   def __init__(self, xMin, xMax, yMin, yMax, squareDim, useOrderedIndex, **kargs):

      # these are the data structures that map the line/contig seg hash to the
      # line / contig seg. These maps are universal in that the hash of a line or
      # contig seg can be determined using the physical attributes of the line or contig seg
      self.lineMap = kargs.get("lineMap")
      self.contigSegsMap = kargs.get("contigSegsMap")

      self.linesInsertedIntoGrid = 0
      self.holesInsertedIntoGrid = 0
      self.linesProcessed = 0
      self.holesProcessed = 0

      # the map of idx (either line or contig seg idx) to the line or the
      # contig seg object is ONLY for this specific instance of the grid
      # because the index is generated by incrementing the maxLine/ContigSegIdx
      # upon each insertion - thus this idx only makes sense in this context
      # This is used for crawling redundant segs to save check redundant operations
      # since we know the line idxs in contig segs are sequential when we insert
      # the contig seg into the grid
      self.useOrderedIndex = useOrderedIndex
      self.maxLineSegIdx = 0
      self.maxContigSegIdx = 0

      # have a map of lineIdx to the grids they occupy
      self.lineSegIdxToGridsOccupied = {}
      self.holeIdxToGridsOccupied = {}

      self.lineSegIdxToLineSeg = {}
      self.contigSegIdxToContigSeg = {}

      self.lineSegIdxToContigSegIdxs = {}

      # to distinguish holes from lines, if we use the ordered indices as determined
      #  by this instance of the gridCls() (where the lines are indexed in order of insertion)
      # then it follows that if we use the ordered indicies as determined for holes,
      # we shall use negative indices to separate from lines
      self.maxHoleSegIdx = -1
      self.holeIdxToHole = {}

      # this map contains as key the ref line seg
      # and as val the list of all line segs that are determined to be redundant
      # with this seg
      self.lineSegToPairedLineSegs = {}
      # this list is contains the sorted keys of the above map that will be used
      #  as reference idxs when crawling for parallel segs
      self.inOrderRefIdxs = []

      # this map contains the exact opposite as above in the same format
      #  key as ref line seg and as val the list of all line segs that are
      #  determined to be NOT REDUNDANT with this seg - this prevents
      #  multiple checks of the SAME pairs that do NOT satisfy condition
      self.lineSegToNONPairedLineSegs = {}

      # this map contains the pairing of the ref contiguous segs
      # with its corresponding sec contiguous segs
      #
      #  contiguous segs are defined as segs that have consecutive idxs AND belong to the same contigSeg
      #
      # NOTE: this map only contains the longest ref contiguous segs ie. with largest span (startIdx, endIdx)
      #       and its corresponding sec contiguous segs
      #   has form {(refSegStartIdx1, refSegEndIdx1) : [(secSegStartIdx1, secSegEndIdx1), ..., (secSegStartIdxN, secSegEndIdxN)]}
      self.maxRefContigSegToRedundantSecContigSegs = {}

      # this map contains the pairing of contig seg to the line idxs within the contig seg to delete
      self.contigSegIdxToLinesToDel = {}

      # this map contains the ref seg idx to lineCls objects which contain the cropped or completely deleted line
      #   that is of idx ref seg idx in the form of
      #  {refIdx : [lineClsObj1, ..., lineClsObjN]}
      self.refSegIdxToCroppedLineSegs = {}

      # this section defines the adjacency maps used by the grid
      self.linesAdjMap = objAdjacencyMapCls()

      self.bufferFactor = 2
      self.squareDim = squareDim

      self.gridXMin = xMin - self.bufferFactor * self.squareDim
      self.gridXMax = xMax + self.bufferFactor * self.squareDim
      self.gridYMin = yMin - self.bufferFactor * self.squareDim
      self.gridYMax = yMax + self.bufferFactor * self.squareDim

      # store the number of squares in a tuple
      # self.numOfXSquares = int((self.gridXMax - self.gridXMin)/self.squareDim) + 1
      # self.numOfYSquares = int((self.gridYMax - self.gridYMin)/self.squareDim) + 1
      self.numOfSquares = (int((self.gridXMax - self.gridXMin)/self.squareDim) + 1, int((self.gridYMax - self.gridYMin)/self.squareDim) + 1)

      # store the min x and val values of each square at its idx
    #  self.squareXVals = [self.gridXMin + i*self.squareDim for i in self.numOfXSquares]
    #  self.squareYVals = [self.gridYMin + i*self.squareDim for j in self.numOfYSquares]

      self.squareVals = ([self.gridXMin + i*self.squareDim for i in range(self.numOfSquares[0])], [self.gridYMin + j*self.squareDim for j in range(self.numOfSquares[1])])

      self.Grid = [[squareCls(self.gridXMin + i*self.squareDim, self.gridYMin + j*self.squareDim, self.squareDim) for j in range(self.numOfSquares[1])] for i in range(self.numOfSquares[0])]

   def insertLineIntoMaps(self, line):
      # insert the seg into individSegIdxToIndividSeg
      if self.useOrderedIndex:
         lineIdx = self.maxLineSegIdx
         self.maxLineSegIdx += 1
      else:
         lineIdx = line.getHash()

      self.lineSegIdxToLineSeg[lineIdx] = line
      return lineIdx

   def removeLineFromMaps(self, line=None, lineIdx=None):
      if not line and not lineIdx:
         print("ERROR - removeLineFromMaps: Need to pass in either line object or line index")
         return

      # if useOrderedIndex - need to crawl the map unless lineIdx is passed in
      idx = None
      linePopped = None
      if lineIdx != None:
         idx = lineIdx
      elif not self.useOrderedIndex:
         idx = line.getHash()

      if idx:
         linePopped = self.lineSegIdxToLineSeg.pop(idx)

      if not linePopped:
         # if idx is not provided - crawl thru the line to look for
         for segIdx, lineSeg in self.lineSegIdxToLineSeg.items():
            if lineSeg == line:
               self.lineSegIdxToLineSeg.pop(segIdx)
               break

   def insertHoleIntoMaps(self, hole, inHoleIdx=None):
      if inHoleIdx:
         holeIdx = inHoleIdx
      else:
         if self.useOrderedIndex:
            holeIdx = self.maxHoleSegIdx
            self.maxHoleSegIdx -= 1
         else:
            holeIdx = hole.getHash()

      self.holeIdxToHole[holeIdx] = hole
      return holeIdx

   def removeHoleFromMaps(self, hole=None, inHoleIdx=None):
      # if useOrderedIndex - need to crawl the map unless lineIdx is passed in
      if not hole and not inHoleIdx:
         print("ERROR - removeHoleFromMaps: Need to pass in either hole object or hole index")
         return

      idx = None
      holePopped = None
      if inHoleIdx != None:
         idx = inHoleIdx
      elif not self.useOrderedIndex:
         idx = hole.getHash()

      if idx:
         holePopped = self.holeIdxToHole.pop(idx)

      if not holePopped:
         # if idx is not provided - crawl thru the line to look for
         for holeIdx, holeSeg in self.holeIdxToHole.items():
            if holeSeg == hole:
               self.holeIdxToHole.pop(segIdx)
               break

   # API to check if the lineCls obj is a hole or not
   def checkIfObjIsHole(self, obj=None, objIdx=None):
      if not objIdx and not obj:
         print("ERROR - checkIfLineObjIsHole: Need to pass in either object or object index")
         return False

      isFound = False
      idx = None
      hole = None

      if objIdx != None:
         idx = objIdx
      else:
         idx = obj.getHash()

      if idx:
         hole = self.holeIdxToHole.get(idx)

      if not hole:
         for holeIdx, hole in self.holeIdxToHole.items():
            if hole == obj:
               isFound = True
               break
      else:
         isFound = True

      return isFound


   def insertLineSegIntoContigSegMaps(self, line, lineIdx, contigSegIdx):
      if self.lineSegIdxToContigSegIdxs.get(lineIdx):
         print("line idx " + str(lineIdx) + " is NOT unique to contig seg + " + str(contigSegIdx) + " - error")
      else:
         self.lineSegIdxToContigSegIdxs[lineIdx] = contigSegIdx

   # this API returns the lines in the grid as a list
   # this incorporates any modified lines that are stored in
   #   self.refSegIdxToCroppedLineSegs
   def returnLinesInGrid(self):
      retLineSegs = []
      print("CroppedLineSegs - %s" % (self.refSegIdxToCroppedLineSegs))
      for lineIdx in self.lineSegIdxToLineSeg:
         if lineIdx in self.refSegIdxToCroppedLineSegs:
            retLineSegs.extend(self.refSegIdxToCroppedLineSegs[lineIdx])
         else:
           retLineSegs.append(self.lineSegIdxToLineSeg[lineIdx])

      return retLineSegs

   # this API returns the lines that were removed (ie. became holes)
   #  in the grid as a list
   def returnRmvedLinesInGrid(self):
      return [hole for holeIdx, hole in self.holeIdxToHole.items() if not hole.checkIfLineIsPoint()]

   def displayGridData(self):
      print(gridCls.displayDelimiter)
      print("square dimensions - " + str(self.squareDim))
      print("grid X min - " + str(self.gridXMin))
      print("grid X max - " + str(self.gridXMax))
      print("grid Y min - " + str(self.gridYMin))
      print("grid Y max - " + str(self.gridYMax))
      print("Number of squares along X - " + str(self.numOfSquares[0]))
      print("Number of squares along Y - " + str(self.numOfSquares[1]))
      print("XMin of squares - " + str(self.squareVals[0]))
      print("YMin of squares - " + str(self.squareVals[1]))
      print(gridCls.displayDelimiter)

   def displayGridSquareData(self):
      for i in range(self.numOfSquares[0]):
         for j in range(self.numOfSquares[1]):
            print("Square with Xind " + str(i) + " and Yind " + str(j) + " info: ")
            self.Grid[i][j].displaySquareData()

   def displayMapNice(self, inputMap):
      for key, vals in inputMap.items():
         print(str(key) + " : " + str(vals))

   def getSquareXYIdxsThatLineStartsIn(self, line):
      # use idx 0, 1 to determine x, y instead of having the same logic twice
      line.calcLineMetadata()

      startPt = line.termPt1
      retList = [0,0]

      # first look for the square that the start pt of the line is in
      for i in range(2):
         # check x or y square
         startIdx = 0
         endIdx = self.numOfSquares[i]-1
         iterIdx = int((endIdx - startIdx)/2)

         prevIterIdx = iterIdx

         while not ( (startPt[i] >= self.squareVals[i][iterIdx]) and \
                     (startPt[i] < (self.squareVals[i][iterIdx]+self.squareDim)) ):

            if startPt[i] >= self.squareVals[i][iterIdx]+self.squareDim:
               print("start pt with idx " + str(i) + " : " + str(startPt[i]) + \
                     " is greater than max (" + str(i) + ") " + \
                     str(self.squareVals[i][iterIdx]+self.squareDim) + \
                     " of square idx " + str(iterIdx) + " - shift startIdx to iterIdx")
               startIdx = iterIdx
            elif startPt[i] < self.squareVals[i][iterIdx]:
               print("start pt with idx " + str(i) + " : " + str(startPt[i]) + \
                     " is less than min (" + str(i) + ") " + \
                     str(self.squareVals[i][iterIdx]) + " of square idx " + \
                     str(iterIdx) + " - shift endIdx to iterIdx")
               endIdx = iterIdx

            iterIdx = int((endIdx - startIdx)/2) + startIdx
            print("iterIdx is " + str(iterIdx) + " prevIdx is " + str(prevIterIdx))
            if prevIterIdx == iterIdx:
               print("coord " + str(i) + " iteration is stuck at value " + \
               str(iterIdx) + " with val " + str(self.squareVals[i][iterIdx]) + \
               " - break out of while loop")
               return None

            prevIterIdx = iterIdx

         retList[i] = iterIdx

      # need special handling for lines with start pts that are on boundary of the squares
      squareCandidate = self.Grid[retList[0]][retList[1]]

      if (startPt[0] == squareCandidate.xMin) and \
         (np.dot(line.unitVect, self.xPosVect) < 0):
         retList[0] -= 1

      if (startPt[0] == squareCandidate.xMax) and \
         (np.dot(line.unitVect, self.xPosVect) > 0):
         retList[0] += 1

      if (startPt[1] == squareCandidate.yMin) and \
         (np.dot(line.unitVect, self.yPosVect) < 0) :
         retList[1] -= 1

      if (startPt[1] == squareCandidate.yMax) and \
         (np.dot(line.unitVect, self.yPosVect) > 0):
         retList[1] += 1


      print("line with info ")
      line.displayLineInfo()
      print(" belongs in square " + str(retList) + " with dimensions ")
      self.Grid[retList[0]][retList[1]].displaySquareData()

      return retList

   def insertLineIdxIntoGridSquare(self, xIdx, yIdx, retLineIdx):
      print("inserting line idx %s into grid with square xIdx %s and yIdx %s" %
             (retLineIdx, xIdx, yIdx))
      self.Grid[xIdx][yIdx].insertLineIdxIntoSquare(retLineIdx)
      self.linesInsertedIntoGrid += 1

      if self.lineSegIdxToGridsOccupied.get(retLineIdx):
         if not (xIdx, yIdx) in self.lineSegIdxToGridsOccupied[retLineIdx]:
            self.lineSegIdxToGridsOccupied[retLineIdx].append((xIdx, yIdx))
      else:
         grids = [(xIdx, yIdx)]
         self.lineSegIdxToGridsOccupied[retLineIdx] = grids

   def insertHoleIdxIntoGridSquare(self, xIdx, yIdx, retLineIdx):
      print("inserting hole idx %s into grid with square xIdx %s and yIdx %s" %
             (retLineIdx, xIdx, yIdx))
      self.Grid[xIdx][yIdx].insertLineIdxIntoSquare(retLineIdx)
      self.holesInsertedIntoGrid += 1

      if self.holeIdxToGridsOccupied.get(retLineIdx):
         if not (xIdx, yIdx) in self.holeIdxToGridsOccupied[retLineIdx]:
            self.holeIdxToGridsOccupied[retLineIdx].append((xIdx, yIdx))
      else:
         grids = [(xIdx, yIdx)]
         self.holeIdxToGridsOccupied[retLineIdx] = grids

   def removeLineIdxFromGridSquare(self, xIdx, yIdx, retLineIdx):
      print("remove line idx %s intro grid with square xIdx %s and yIdx %s" %
            (retLineIdx, xIdx, yIdx))
      self.Grid[xIdx][yIdx].removeLineIdxFromSquare(retLineIdx)
      self.linesInsertedIntoGrid -= 1

      try:
         self.lineSegIdxToGridsOccupied.get(retLineIdx, []).remove((xIdx, yIdx))
      except:
         print("Line Entry (%s, %s) not found in grids occupied %s" %
               (self.lineSegIdxToGridsOccupied.get(retLineIdx, [])))

   def removeHoleIdxFromGridSquare(self, xIdx, yIdx, retLineIdx):
      print("remove hole idx %s intro grid with square xIdx %s and yIdx %s" %
            (retLineIdx, xIdx, yIdx))
      self.Grid[xIdx][yIdx].removeLineIdxFromSquare(retLineIdx)
      self.holesInsertedIntoGrid -= 1

      try:
         self.holeIdxToGridsOccupied.get(retLineIdx, []).remove((xIdx, yIdx))
      except:
         print("Hole Entry (%s, %s) not found in grids occupied %s" %
               (self.holeIdxToGridsOccupied.get(retLineIdx, [])))

   # This API gets the grid squares that the line goes into
   #  and nothing else (ie. it does not populate any maps)
   def getGridSquaresThatLineBelongsTo(self, line, lineIdx):
      # check which square the line belongs in
      squaresOccupied = []
      squareXYIdxs = self.getSquareXYIdxsThatLineStartsIn(line)
      if not squareXYIdxs:
         print("failed to find the square that " + str(line.termPt1) + " belongs to")
         return False, squaresOccupied

      insertStatus = True
      #given the square X/Y idxs - now set the line starting from that square X/Y idx
      retLine = self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].getLineThatFitsIntoSquare(line)
      if retLine:
         print("inserting line idx " + str(lineIdx) + " with start pt " + \
               str(retLine.termPt1) + " and end pt " + str(retLine.termPt2) + \
               " into square with Xidx " + str(squareXYIdxs[0]) + \
               " and Yidx " + str(squareXYIdxs[1]))

         print("orig line start pt " + str(line.termPt1) + " and end pt " + str(line.termPt2))
         self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].displaySquareData()
         squaresOccupied.append((squareXYIdxs[0], squareXYIdxs[1]))
      else:
         insertStatus = False

      # if the end point of the return line is NOT the same as the original line it means
      #  that the line exceeds the dimensions of the square and that the line has been cut
      #  to the dimensions of the square - continue crawling the grid and fitting the line
      #  until all segments have been fit into their corresponding squares in the grid
      while not np.array_equal(line.termPt2, retLine.termPt2):
         # create line that is the remaining portion of the line
         remainLine = lineCls()
         remainLine.setStartPt(retLine.termPt2)
         remainLine.setEndPt(line.termPt2)
         # note that this must lie on the border (xMin, xMax, yMin, yMax)
         #  if point is on xMin - means the x idx for the next square is curr x idx - 1
         #  if point is on xMax - means the x idx for the next square is curr x idx + 1
         #  if point is on yMin - means the y idx for the next square is curr y idx - 1
         #  if point is on yMax - means the y idx for the next square is curr y idx + 1
         xDelta = yDelta = 0
         if (retLine.termPt2[0] == self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].xMin) and \
            (np.dot(line.unitVect, self.xPosVect) < 0):
            xDelta = -1
         if (retLine.termPt2[0] == self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].xMax) and \
            (np.dot(line.unitVect, self.xPosVect) > 0):
            xDelta = 1
         if (retLine.termPt2[1] == self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].yMin) and \
            (np.dot(line.unitVect, self.yPosVect) < 0):
            yDelta = -1
         if (retLine.termPt2[1] == self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].yMax) and \
            (np.dot(line.unitVect, self.yPosVect) > 0):
            yDelta = 1

         squareXYIdxs[0] += xDelta
         squareXYIdxs[1] += yDelta

         retLine = self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].getLineThatFitsIntoSquare(remainLine)
         if retLine:
            print("inserting line idx " + str(lineIdx) + " with start pt " + \
                  str(retLine.termPt1) + " and end pt " + str(retLine.termPt2) + \
                  " into square with Xidx " + str(squareXYIdxs[0]) + " and Yidx " + str(squareXYIdxs[1]))

            print("orig line start pt " + str(line.termPt1) + " and end pt " + str(line.termPt2))
            self.Grid[squareXYIdxs[0]][squareXYIdxs[1]].displaySquareData()
            squaresOccupied.append((squareXYIdxs[0], squareXYIdxs[1]))
         else:
            insertStatus = False

      if not insertStatus:
         print("ERROR in retrieving the squares that the line occupies - %s" % (squaresOccupied))

      return insertStatus, squaresOccupied

   # This API purely performs the insertion of a line into the grid squares
   #  and nothing else (ie. it does not populate any maps)
   #
   # This API is to allow insertion of lines OR holes or whatever segments needed to be inserted
   # that doesn't need to be handled by any map
   def insertLineObjIntoGridSquares(self, line, lineIdx):
      # check which squares the line belong to
      status, squaresOccupied = self.getGridSquaresThatLineBelongsTo(line, lineIdx)

      # the output of squares occupied are its x- and y-coord
      for square in squaresOccupied:
         self.insertLineIdxIntoGridSquare(square[0], square[1], lineIdx)

      return status, squaresOccupied

   # This API purely performs deletion of line from the grid squares
   #  and nothign else (ie. it does not populate any maps)
   #
   # This API is to allow deletion of lines OR holes or whatever segments needed to be deleted
   # that doesn't need to be handled by any map
   def deleteLineObjFromGridSquares(self, line, lineIdx):
      # check which squares the line belong to
      status, squaresOccupied = self.getGridSquaresThatLineBelongsTo(line, lineIdx)

      for square in squaresOccupied:
         self.removeLineIdxFromGridSquare(square[0], square[1], lineIdx)

      return status, squaresOccupied

   # API to insert line into grid coordinates - this API
   # is to insert a line into the Grid and process the lines before
   # these lines have become contigsSegs
   def insertLineIntoGrid(self, line):
      # insert the line into lineSegMap
      retLineIdx = self.insertLineIntoMaps(line)
      insertStatus, squaresOccupied = self.insertLineObjIntoGridSquares(line, retLineIdx)

      if insertStatus:
         self.linesProcessed += 1

      return insertStatus, retLineIdx

   # API to deleteline from grid coordinates - this API
   # is to remove a line from the grid and reverse the processing of the lines
   def removeLineFromGrid(self, line, lineIdx=None):
      # remove the line from lineSegMap
      if not lineIdx:
         lineIdx = line.hash
      self.removeLineFromMaps(line, lineIdx)
      dltStatus, squaresOccupied = self.deleteLineObjFromGridSquares(line, lineIdx)

      if dltStatus:
         self.linesProcess -= 1

      return dltStatus, lineIdx

   # API to insert hole into grid coordinates - this API
   # is to insert a hoel into the Grid squares AND the hole map in this
   # gridCls instance
   def insertHoleIntoGrid(self, hole):
      # insert the hole into holeMap
      retHoleIdx = self.insertHoleIntoMaps(hole)
      insertStatus, squaresOccupied = self.insertLineObjIntoGridSquares(hole, retHoleIdx)

      if insertStatus:
         self.holesProcessed += 1

      return insertStatus, retHoleIdx

   # insert map of lines into grid
   def insertLineMapIntoGrid(self, lineMap):
      retCode = True
      for lineIdx, line in lineMap.items():
         insertStatus, retLineIdx = self.insertLineIntoGrid(line)

         if not insertStatus:
            print("Failed to insert line with idx %s" % lineIdx)
            line.displayLineInfo()
            retCode = False

      return retCode

   # the input contig seg has not yet been split
   #  into the grid coordinates
   #
   # ALSO NOTE: the line segs in each contig seg is indexed sequentially, meaning
   #  that the line seg idxs in each contig seg should be sequential and be contiguous (ie. differ by 1)
   def insertContigSegIntoGrid(self, contigSeg):
      retCode = True
      mapContigSeg = contigSegCls()

      if self.useOrderedIndex:
         mapContigSegIdx = self.maxContigSegIdx
      else:
         mapContigSegIdx = contigSeg.generateHashValueForContigSeg()

      for i in range(len(contigSeg.lineIdxs)):
         line = contigSeg.lines[i]

         insertStatus, retLineIdx = self.insertLineIntoGrid(line)

         if insertStatus:
            #contigSeg.lineIdxs[i] = retLineIdx

            # insert line params into contigSeg maps
            self.insertLineSegIntoContigSegMaps(line, retLineIdx, mapContigSegIdx)

            #insertLineToContigSeg input (lineIdx, line, checkDotProd, insertIdxOnly)
            mapContigSeg.insertLineToContigSeg(retLineIdx, line, False, True)

      # check that contigSeg is contiguous
      if not mapContigSeg.checkContigSegIsContiguous(self.lineSegIdxToLineSeg):
         print("mapContigSeg is NOT contiguous - check logs above for source of error")
         retCode = False
      else:
         # copy the combinedLinesAndCurves list into the mapContigSeg
         mapContigSeg.combinedLinesAndCurves = copy.deepcopy(contigSeg.combinedLinesAndCurves)
         # insert mapContigSeg into contigSegIdxToContigSeg
         mapContigSeg.calcContigSegMetadata(self.lineSegIdxToLineSeg)
         self.contigSegIdxToContigSeg[mapContigSegIdx] = mapContigSeg

         if self.useOrderedIndex:
            self.maxContigSegIdx += 1

      return retCode

############ APIs to populate the adjacency maps (so far only have LINECLS
############ adjacency maps)
   def insertLineIntoAdjMap(self, lineObj):
      self.linesAdjMap.insertObjIntoAdjMap(lineObj)

   def insertAllLinesIntoAdjMap(self):
      for lineIdx, lineObj in self.lineSegIdxToLineSeg.items():
         self.insertLineIntoAdjMap(lineObj)

   # API to delete the lineCls object with idx from the Grid squares
   #  stored as self.Grid
   def deleteLineFromGrid(self, inLineIdx):
      gridsOccupied = self.lineSegIdxToGridsOccupied.get(inLineIdx)
      for gridEntry in gridsOccupied:
         self.Grid[gridEntry[0]][gridEntry[1]].removeLineIdx(inLineIdx)

   # API that takes in a lineCls object idx (could be a line or a hole)
   # and returns all of the lineCls object idxs that are within a grid's distance
   #  (-1, 0, +1) delta in the x- and y-direction from the grids that the lineCls
   # object occupies
   def getProximityLineIdxs(self, lineObjIdx, delta=1):
      proxLineObjIdxs = []
      # the grids occupied by the lineObjIdx (can be line or hole) are stored
      # in lineSegIdxToGridsOccupied in tuple for
      # here we must search thru ALL of the neighbors because we are systematically crawling
      # thru every single grid square
      for gridCoord in self.lineSegIdxToGridsOccupied.get(lineObjIdx):
         lineIdxsInArea = self.getLineSegsOfGridAndNeighbors(gridCoord, delta)
         for neighborLineObjIdx in lineIdxsInArea:
            if neighborLineObjIdx != lineObjIdx and \
               neighborLineObjIdx not in proxLineObjIdxs:
               proxLineObjIdxs.append(neighborLineObjIdx)

      return proxLineObjIdxs

   # API that takes in a lineCls object (could be a line or a hole)
   # and returns all of the lineCls obj idxs that are within a grid's distance
   # delta in the x- and y-direction from the grids that the lineCls object occcupies
   def getProximityObjIdxs(self, obj, delta):
      proxObjIdxs = []
      status, squaresOccupied = self.getGridSquaresThatLineBelongsTo(obj, 0)
      if not status:
         print("getProximityObjs - ERROR: cannot find squares that obj below belongs to")
         obj.displayLineInfo()
      else:
         for square in squaresOccupied:
            objIdxsInArea = self.getLineSegsOfGridAndNeighbors(square, delta)
            for neighborObjIdx in objIdxsInArea:
               if not neighborObjIdx in proxObjIdxs:
                  proxObjIdxs.append(neighborObjIdx)
      return proxObjIdxs

   # API that takes in a lineCls object (can be a line or a hole)
   # and return all of the holes that are within grid's distance delta in the
   # x- and y-direction from the grids that the lineCls object occupies
   def getProximityLineObjs(self, obj, delta):
      proxObjIdxs = self.getProximityObjIdxs(obj, delta)
      lineObjsProcessed = {}
      lineObjs = []
      for proxObjIdx in proxObjIdxs:
         lineObj = self.lineSegIdxToLineSeg.get(proxObjIdx)
         if lineObj and obj != lineObj and not lineObjsProcessed.get(lineObj):
            lineObjs.append(lineObj)
            lineObjsProcessed[lineObj] = True
      return lineObjs

   def getProximityHoleObjs(self, obj, delta):
      proxObjIdxs = self.getProximityObjIdxs(obj, delta)
      holeObjsProcessed = {}
      holeObjs = []
      for proxObjIdx in proxObjIdxs:
         holeObj = self.holeIdxToHole.get(proxObjIdx)
         if holeObj and obj != holeObj and not holeObjsProcessed.get(holeObj):
            holeObjs.append(holeObj)
            holeObjsProcessed[holeObj] = True
      return holeObjs

   # API that returns the line segs idxs in the input grid and the neighboring grids
   # INPUTS:
   #   center grid to look at
   #   the span of the surrounding grids
   # OUTPUT: list of line segments that belong to those grids
   def getLineSegsOfGridAndNeighbors(self, gridCoord, radius):
      gridAreaLineIdxs = []
      neighborGrids = [(0,0), (0,radius), (0,-radius), (radius,0), (-radius,0), \
                       (radius,radius), (-radius,radius), (radius,-radius), (-radius,-radius)]
      for neighbor in neighborGrids:
         xNeighborCoord = gridCoord[0] + neighbor[0]
         yNeighborCoord = gridCoord[1] + neighbor[1]
         if xNeighborCoord < 0 or xNeighborCoord > (self.numOfSquares[0]-1) or \
            yNeighborCoord < 0 or yNeighborCoord > (self.numOfSquares[1]-1):
            continue

         gridAreaLineIdxs.extend(self.Grid[xNeighborCoord][yNeighborCoord].lineSegsInSquare)

      return gridAreaLineIdxs


   # API to check if the line idxs in the input list belong to the same contigSeg
   #   The lineSegIdxToContigSegIdxs map contains {lineSegIdx : contigSegIdx}
   #   Each lineSegIdx corresponds to a contigSegIdx even if 2 lineSegs are the same (same start pt and end pt)
   #   They will have different lineSegIdx
   def checkIfLineIdxsBelongToSameContigSeg(self, listOfLineSegs):
      firstContigSegIdx = self.lineSegIdxToContigSegIdxs[listOfLineSegs[0]]
      for elemIdx in range(1, len(listOfLineSegs)):
         if self.lineSegIdxToContigSegIdxs[listOfLineSegs[elemIdx]] != firstContigSegIdx:
            return False

      return True

#### APIs to return the sorted order of lines or contig segs according to their
#### lengths - either from shortest to longest OR from longest to shortest
#### default = longest to shortest
   def getLinesSortedByLen(self, reversed=True):
      linesToLen = {}
      for idx, line in self.lineSegIdxToLineSeg.items():
         linesToLen[line] = line.getLength()

      return dict(sorted(linesToLen.items(), key=lambda entry: entry[1], reverse=reversed))

   def getContigSegsSortedByLen(self, reversed=True):
      contigSegsToLen = {}
      for idx, contigSeg in self.contigSegIdxToContigSeg:
         contigSegsToLen[contigSeg] = contigSeg.getLength()

      return dict(sorted(contigSegsToLen.items(), key=lambda entry: entry[1], reverse=reversed))

   # API to convert the map from format of {ref seg : [redundantSeg1, redundantSeg2, ..., redundantSegN]}
   #
   #   into {(refSeg, contigSegRefSegBelongTo, lenOfContigSeg) : [(redundSegStart1, redundSegEnd1, contigSegLinesBelongTo, lenOfContigSeg),
   #                                                              (redundSegStart2, ..., redundSegEnd2, contigSegLinesBelongTo, lenOfContigSeg)]}
   #
   #   where redundSegStart1 is the redundant seg with the lowest index belonging to a contigSeg and redundSegEnd1 is
   #   is the highest index belonging to the same contiguous segment (ie. the initial map contains redundSegStart1,
   #   redundSegStart1+1, redundSegStart+2, .., redundSegEnd1)
   #
   # reason for this structure is to move to multiprocessing as a future speedup
   def convertLineSegToLineSegsTupleMap(self, origMap, startIdx, endIdx):
      retMap = {}
      origMapKeyList = list(origMap.keys())
      # loop thru the origMap to convert format to above where store only start and end idx of same contig seg
      for i in range(startIdx, endIdx+1):
         lineSegVals = origMap.get(origMapKeyList[i])
         if lineSegVals:
            newLineSegGroups = []
            newLineSegGroup = []
            # first - sort since the line segs are initially generated in order for each contig seg
            #  so line segs belonging in contig seg would have contiguous
            lineSegVals.sort()
            startSeg = endSeg = None
            for valsIdx in range(len(lineSegVals)-1):
               if not startSeg:
                  startSeg = lineSegVals[valsIdx]
                  endSeg = startSeg
                  # try using the length of the web that the contig seg belongs to
                  contigSegOfLine = self.contigSegIdxToContigSeg[self.lineSegIdxToContigSegIdxs[lineSegVals[valsIdx]]]
                  if self.contigSegsMap:
                    # csLength = self.contigSegsMap.contigSegHashToWebLen.get(contigSegOfLine.hash, contigSegOfLine.length)
                     csLength = contigSegOfLine.length
                  else:
                     csLength = contigSegOfLine.length
                  newLineSegGroup = [startSeg, endSeg,\
                                     self.lineSegIdxToContigSegIdxs[lineSegVals[valsIdx]], \
                                     csLength]

               # terminate the tuple if:
               #  1) the lineSegIdx at the current position is NOT contiguous (+1) the lineSegIdx at the immediate prev position
               #  2) check if the lines are contiguous using checkIf2LinesAreContiguous API
               #  3) the lineSegIdx at the current position DOES NOT belong to the same contigSeg as the lineSegIdx at the immediate prev position
               if ((lineSegVals[valsIdx+1] - lineSegVals[valsIdx]) != 1) or \
                  (checkIf2LinesAreContiguous(self.lineSegIdxToLineSeg[lineSegVals[valsIdx]], self.lineSegIdxToLineSeg[lineSegVals[valsIdx+1]]) is None) or \
                  not self.checkIfLineIdxsBelongToSameContigSeg([lineSegVals[valsIdx+1], lineSegVals[valsIdx]]):
                  newLineSegGroup[1] = lineSegVals[valsIdx]
                  newLineSegGroup[2] = self.lineSegIdxToContigSegIdxs[lineSegVals[valsIdx]]
                  contigSegOfLine = self.contigSegIdxToContigSeg[self.lineSegIdxToContigSegIdxs[lineSegVals[valsIdx]]]
                  if self.contigSegsMap:
                    # csLength = self.contigSegsMap.contigSegHashToWebLen.get(contigSegOfLine.hash, contigSegOfLine.length)
                     csLength = contigSegOfLine.length
                  else:
                     csLength = contigSegOfLine.length
                  newLineSegGroup[3] = csLength
                  newLineSegGroups.append((newLineSegGroup[0], newLineSegGroup[1], newLineSegGroup[2], newLineSegGroup[3]))
                  newLineSegGroup = []
                  startSeg = endSeg = None
               else:
                  newLineSegGroup[1] = lineSegVals[valsIdx+1]


            # check if the last element in lineSegVals is absorbed as newLineSegsGroup as an endpt - if it is, this means
            # that newLineSegGroup is filled - need to push it into newLineSegGroups
            if newLineSegGroup:
               newLineSegGroups.append((newLineSegGroup[0], newLineSegGroup[1], newLineSegGroup[2], newLineSegGroup[3]))
            # if the newLineSegGroup is empty this means that the last seg does NOT belong in the same group as the second to last line seg
            #  need to explicitly create a tuple for the last seg
            else:
               contigSegOfLine = self.contigSegIdxToContigSeg[self.lineSegIdxToContigSegIdxs[lineSegVals[-1]]]
               if self.contigSegsMap:
                #  csLength = self.contigSegsMap.contigSegHashToWebLen.get(contigSegOfLine.hash, contigSegOfLine.length)
                  csLength = contigSegOfLine.length
               else:
                  csLength = contigSegOfLine.length
               newLineSegGroups.append((lineSegVals[-1], lineSegVals[-1], \
                                        self.lineSegIdxToContigSegIdxs[lineSegVals[-1]], \
                                        csLength))

            contigSegOfLine = self.contigSegIdxToContigSeg[self.lineSegIdxToContigSegIdxs[origMapKeyList[i]]]
            if self.contigSegsMap:
               #csLength = self.contigSegsMap.contigSegHashToWebLen.get(contigSegOfLine.hash, contigSegOfLine.length)
               csLength = contigSegOfLine.length
            else:
               csLength = contigSegOfLine.length
            retMap[(origMapKeyList[i], \
                    self.lineSegIdxToContigSegIdxs[origMapKeyList[i]], \
                    csLength)] = newLineSegGroups

      return retMap

   # API to loop through square grid to resolve the paired line segs
   #   loop thru each square to determine which segs are paired
   #     - to determine which segs are "paired" check if 2 line segs are:
   #         1) within proximity to each other by checking lines in grids and neighboring grids
   #         2) satisfy the condition that the 2 lines should be paired - this condition is
   #            determined by passing 2 lines into the function that is passed as input into
   #            this function (for example checkIf2LinesRedundant OR checkIf2LinesIntersect) - these 2
   #            conditions are functions that are passed in as input into this function
   #           Any extra arguments that this input function needs are passed as **kargs (keyed arguments)
   #Put the lineSegToPairedLineSegs map and the NOT parallels into lineSegToNONPairedLineSegs
   #
   # input - raw 2d grid of squares containing line indices of lines within each square on grid
   # output - generate map in form of {refSeg : [(redundStart1, ..., redundEnd1), (redundStart2, ..., redundEnd2)]}
   def crawlThruGridToResolvePairedSegs(self, inputPairCond, **kargs):
      foundRedundant = False
      # only need to look at neighbors in :
      #   (0, 1), (1, 0), (1, 1) direction since this API moves from top LHS corner of grid
      #   thus, no need for negative coord since sweep looks at +ve direction
      #   also - need to look at proximity lines in own grid (to do this add (0,0) as dummy neighbor)
      neighborGrids = [(0,0), (0,1), (1,0), (1,1), (-1, 1)]
      # loop thru y-coord
      for j in range(self.numOfSquares[1]):
         # loop thru x-coord
         for i in range(self.numOfSquares[0]):
            for neighbor in neighborGrids:
               xneighbor = i + neighbor[0]
               yneighbor = j + neighbor[1]

               # if either the x or the y neighbor is out of bounds of the grid
               # continue to the next potential neighbor
               if xneighbor < 0 or xneighbor > (self.numOfSquares[0]-1) or \
                  yneighbor < 0 or yneighbor > (self.numOfSquares[1]-1):
                  continue

               # compare the line segs in the grid and in the adjacent grid to see if they are redundant
               for lineIdx1 in self.Grid[i][j].lineSegsInSquare:
                  for lineIdx2 in self.Grid[xneighbor][yneighbor].lineSegsInSquare:

                     # if the 2 line segs have already been determined to be parallel / redundant or NOT
                     #  or if the 2 lines have the same idx (ie. are the same line)
                     if ( lineIdx1 == lineIdx2 ) or \
                        ( self.lineSegToPairedLineSegs.get(lineIdx1, None) and \
                          lineIdx2 in self.lineSegToPairedLineSegs.get(lineIdx1, None) ) or \
                        ( self.lineSegToNONPairedLineSegs.get(lineIdx1, None) and \
                          lineIdx2 in self.lineSegToNONPairedLineSegs.get(lineIdx1, None) ):
                        continue

                     # check if the 2 lines are parallel / redundant
                     if inputPairCond(self.lineSegIdxToLineSeg.get(lineIdx1), \
                                      self.lineSegIdxToLineSeg.get(lineIdx2), \
                                      maxPerpDist=kargs.get("maxPerpDist", 5.0)):
                        # if the 2 lines are redundant - store them into the
                        #  lineSegToPairedLineSegs map
                        foundRedundant = True
                        if not self.lineSegToPairedLineSegs.get(lineIdx1, None):
                           self.lineSegToPairedLineSegs[lineIdx1] = [lineIdx2]
                        else:
                           self.lineSegToPairedLineSegs[lineIdx1].append(lineIdx2)

                        if not self.lineSegToPairedLineSegs.get(lineIdx2, None):
                           self.lineSegToPairedLineSegs[lineIdx2] = [lineIdx1]
                        else:
                           self.lineSegToPairedLineSegs[lineIdx2].append(lineIdx1)

                     else:
                        # if the 2 lines are NOT redundant - store them into the
                        #  lineSegToNONPairedLineSegs map
                        if not self.lineSegToNONPairedLineSegs.get(lineIdx1, None):
                           self.lineSegToNONPairedLineSegs[lineIdx1] = [lineIdx2]
                        else:
                           self.lineSegToNONPairedLineSegs[lineIdx1].append(lineIdx2)

                        if not self.lineSegToNONPairedLineSegs.get(lineIdx2, None):
                           self.lineSegToNONPairedLineSegs[lineIdx2] = [lineIdx1]
                        else:
                           self.lineSegToNONPairedLineSegs[lineIdx2].append(lineIdx1)

      return foundRedundant


   # API to process the lineSegToPairedLineSegs map so that
   #  1) the keys, which serves as the IN ORDER REFERENCE idxs that we will crawl this map
   #     to determine parallel (redundant) segs, are sorted in ascending order
   #  2) sort the idxs in the corresponding list (value) of parallel / redundant segs
   #      in ascending order
   # input - for now None
   # return - for now, nothing
   def sortRefIdxs(self):
      self.inOrderRefIdx = list(self.lineSegToPairedLineSegs.keys())
      self.inOrderRefIdx.sort()

      for refIdx in self.inOrderRefIdx:
         if self.lineSegToPairedLineSegs.get(refIdx, None):
            secSegs = self.lineSegToPairedLineSegs.get(refIdx)
            secSegs.sort()
            self.lineSegToPairedLineSegs[refIdx] = secSegs

   # API to handle lines that cross each other (but are not identified mathematically
   # as lines that intersect each other)
   # This API will split those lines so that any 2 lines that crosses each other
   #  are now split at the point of the intersection
   #
   # input - for now, none
   # return - for now nothing
   def splitLinesThatCrossAndIntersect(self):
      # this maps stores pairs of line idxs that have been checked whether they
      # intersect or not
      # the key is the pair of line idxs that are checked (with the smaller
      # line idx going first)
      checkedPairTupleMap = {}
      # this map stores the line idx to the pts that it must split up as since
      # these are pts of intersection that htis line has with other lines
      lineIdxToPtsOfIntersection = {}
      # loop thru entries in self.lineSegToPairedLineSegs
      for line1Idx, proxLinesIdx in self.lineSegToPairedLineSegs.items():
         for proxLineIdx in proxLinesIdx:
            # get the pair of line idxs to see if they have been checked
            # whether or not they intersect
            if line1Idx < proxLineIdx:
               checkedKey = (line1Idx, proxLineIdx)
            else:
               checkedKey = (proxLineIdx, line1Idx)
            # check for intersection only if this particular pair has not been
            # checked yet
            if not checkedPairTupleMap.get(checkedKey):
               checkedPairTupleMap[checkedKey] = True
               line1 = self.lineIdxToLineSeg.get(line1Idx)
               proxLine = self.lineIdxToLineSeg.get(proxLineIdx)
               intersectPt = checkIf2LinesIntersect(line1, proxLine)
               # if the intersectPt is not NONE that means these 2 lines intersect
               # and the intersectPt is the pt at which they intersect
               # push in to the lineIdxToPtsOfIntersection map to split this line
               # along those points later
               if intersectPt:
                  if not lineIdxToPtsOfIntersection.get(line1Idx):
                     lineIdxToPtsOfIntersection[line1Idx] = [intersectPt]
                  else:
                     lineIdxToPtsOfIntersection[line1Idx].append(intersectPt)

                  if not lineIdxToPtsOfIntersection.get(proxLineIdx):
                     lineIdxToPtsOfIntersection[proxLineIdx] = [intersectPt]
                  else:
                     lineIdxToPtsOfIntersection[proxLineIdx].append(intersectPt)

      # now that each line has its pts of intersection with other points (if applicable)
      # we must split the line according to those points
      #
      # to split the line accordingly, must determine how the original line
      # is oriented (check the direction of the x- and y-dimensions of the
      # unit vect - if unitVect(x) < 0, this means that that we should sort
      # the pts in decreasing order of x-coord.
      # if unitVect(x) > 0 , sort the pts in increasing order of x-coordinate
      #
      #  NOTE: we use x-coorindate 1st to determine order - if x coord of unitVect is 0
      # (meaning that the line is vertical), then we use the y-coord of unitVect
      # and use the same logic as x-coord to sort the pts but for y-coordinate
      #
      #  We then split the line by creating lineCls objects of (termPt1, intersect1)
      #  (intersect1, intersect2), ..., (intersectN, termPt2)
      for lineIdx, ptsOfIntersecton in lineIdxToPtsOfIntersection.items():
         origLine =  self.lineIdxToLineSeg.get(lineIdx)
         origLineUnitVect = origLine.unitVect
         # check to see direction of x-cord of unitVect
         if origLineUnitVect[0] > 0:
            sortedPtsOfIntersection = sorted(ptsOfIntersection, key=lambda ref: ref[0])
         elif origLineUnitVect[0] < 0:
            sortedPtsOfIntersection = sorted(ptsOfIntersection, key=lambda ref: ref[0], reverse=True)
         elif origLineUnitVect[1] > 0:
            sortedPtsOfIntersection = sorted(ptsOfIntersection, key=lambda ref: ref[1])
         elif origLineUnitVect[1] < 0:
            sortedPtsOfIntersection = sorted(ptsOfIntersection, key=lambda ref: ref[1], reverse=True)
         else:
            sortedPtsOfIntersection = []

         if sortedPtsOfIntersection:
            # first create the lineCls object of termPt1 to 1st point in sortedPtsOfIntersection
            lineSeg = lineCls()
            lineSeg.setStartPt(origLine.termPt1)
            lineSeg.setEndPt(sortedPtsOfIntersection[0])
            self.refSegIdxToCroppedLineSegs[lineIdx] = []
            self.refSegIdxToCroppedLineSegs[lineIdx].append(lineSeg)

            # loop thru and create line segs between each intersection pt
            for idx in range(len(sortedPtsOfIntersection)-1):
               lineSeg = lineCls()
               lineSeg.setStartPt(sortedPtsOfIntersection[idx])
               lineSeg.setEndPt(sortedPtsOfIntersection[idx+1])
               self.refSegIdxToCroppedLineSegs[lineIdx].append(lineSeg)

            # create the last segment of last point in sortedPtsOfIntersection to termPt2
            lineSeg = lineCls()
            lineSeg.setStartPt(sortedPtsOfIntersection[-1])
            lineSeg.setEndPt(origLine.termPt2)
            self.refSegIdxToCroppedLineSegs[lineIdx].append(lineSeg)

      # return nothing for now - will decide later

   # API to crawl thru map in the form of
   # {(refSeg, contigSegRefSegBelongTo, lenOfContigSeg) : [(redundSegStart1, redundSegEnd1, contigSegLinesBelongTo, lenOfContigSeg), (redundSegStart2, ..., redundSegEnd2, contigSegLinesBelongTo, lenOfContigSeg)]}
   #
   #   where redundSegStart1 is the redundant seg with the lowest index belonging to a contigSeg and redundSegEnd1 is
   #   is the highest index belonging to the same contiguous segment (ie. the initial map contains redundSegStart1,
   #   redundSegStart1+1, redundSegStart+2, .., redundSegEnd1)
   #
   # 0) convert the map of self.lineSegToPairedLineSegs from {refSeg : [secSeg1, ..., secSegN]} to
   #     {(refSeg, contigSegIdx, contigSegLen) : [(secSeg1, secSegN, contigSegIdx, contigSegLen), ..]}
   #
   # 1) sort the ref seg tuples in order of longest contigSeg that the refSeg belongs to - that way the longest segs are resolved first, providing
   #    anchors for shorter segs
   #
   # 2) for each ref seg - sort the sec segs by len of contig segs len - longest segs 1st
   #
   # 3) For each grouping of (secSegStart, secSegEnd, contigSeg, contigSegLen) - orient secSegStart and secSegEnd such that
   #    the termPt2 of secSegStart == termPt1 of secSegStart + 1 AND termPt2 of secSegEnd - 1 == termPt1 of secSegEnd
   #
   # 4) Check the orientation of the sec seg group by taking termPt1 of secSegStart and termPt2 of secSegEnd and getting the unit vector
   #    of that direction - check if the direction of refSeg is the same (ie. if UnitVectSec dot UnitVectRef >= 0) - IF NOT, flip refSeg
   #
   # 5) Now that secSeg and refSeg are properly oriented - check projection secSeg onto refSeg to see if refSeg is completely overlap OR
   #    if refSeg has segments that stick out at the start or at the end - use projection equation
   #      termPt1SecStart + A * UnitSecStartPerp = termPt1RefStart + B * UnitRef <-- start seg of secSegs
   #      termPt2SecEnd   + A * UnitSecEndPerp   = termPt2RefEnd   + B * -UnitRef <-- end seg of secSegs
   #  IN THIS CASE - THE REF SEG WILL BE THE "REFERENCE" SEG THAT TAKES AS INPUT THE SEC START / SEC END SINCE B is the value we wish to use
   #  to determine - if B < 0 ---> this means that there are outstanding portions of refSeg that must be stored
   #
   #  NOTE: if FUTURE seg uses PROCESSED seg (seg that was previously crawled ref seg) as anchor - use ORIG ref seg as anchor since anchor seg
   #        redundancy is handled when anchor was ref seg
   #
   #        While looping thru the secSegs for the one ref seg - use the resulting cropped refSeg for each secSegGroup as long as the secSegGroup contigSeg
   #        is longer than the refSeg contig seg
   #
   # input - for now, none
   # return - for now, nothing
   def crawlRefSegsToRmvRedundancy(self):
      refSegTupleToRedundSegTupleMap = self.convertLineSegToLineSegsTupleMap(self.lineSegToPairedLineSegs, 0, len(self.lineSegToPairedLineSegs)-1)
      print("Paired line segs - %s" % (self.lineSegToPairedLineSegs))
      print("ref seg tup to redund tups - %s" % (refSegTupleToRedundSegTupleMap))
      # sort the ref segs in order of contig seg len (entry with idx = 2 in ref tuple since refSegTuple - (refSeg, contigSegIdx, contigSegLen)) in order of longest to shortest
      orderedRefSegs = sorted(refSegTupleToRedundSegTupleMap, key=lambda ref: ref[2], reverse=True)

      for refEntry in orderedRefSegs:
         refSegContigSegLen = refEntry[2]
         secSegs = refSegTupleToRedundSegTupleMap.get(refEntry)
         # sort the sec segs in order of contig seg len (entry with idx = 3 in sec seg tuple - secSegStart, secSegEnd, contigSegIdx, contigSegLen) in order of longest to shortest
         sortedSecSegs = sorted(secSegs, key=lambda sec: sec[3], reverse=True)
         refSeg = self.lineSegIdxToLineSeg.get(refEntry[0])
         refResultSegs = [refSeg]

         for secEntry in sortedSecSegs:
            # check if len of contig seg of secSeg is greater than refSeg contig seg - if not can break since this is sorted by secSeg contigSeg len
            secSegContigSegLen = secEntry[3]
            if secSegContigSegLen < refSegContigSegLen:
               break

            newRefSegs = []
            for refResultSeg in refResultSegs:
               # orient the contig segs
               startSecSeg = self.lineSegIdxToLineSeg.get(secEntry[0])
               endSecSeg = self.lineSegIdxToLineSeg.get(secEntry[1])

               if secEntry[1] != secEntry[0]:
                  startSecSegAdj = self.lineSegIdxToLineSeg.get(secEntry[0]+1)
                  endSecSegAdj = self.lineSegIdxToLineSeg.get(secEntry[1]-1)
               else:
                  startSecSegAdj = endSecSegAdj = None

               # orient the start sec seg such that its end pt is a shared pt with startSecSeg+1
               if (startSecSegAdj and endSecSegAdj):
                  if np.array_equal(startSecSeg.termPt1, startSecSegAdj.termPt1) or \
                     np.array_equal(startSecSeg.termPt1, startSecSegAdj.termPt2):
                     startSecSeg.flipLine()
                  elif not (np.array_equal(startSecSeg.termPt2, startSecSegAdj.termPt1) or \
                            np.array_equal(startSecSeg.termPt2, startSecSegAdj.termPt2)):
                     print("ERROR - startSecSeg does NOT share any pt with startSecSeg+1 - startSecSeg NOT CONTIGUOUS")

                  # orient the end sec seg such that its start pt is a shared pt with endSecSeg-1
                  if np.array_equal(endSecSeg.termPt2, endSecSegAdj.termPt1) or \
                     np.array_equal(endSecSeg.termPt2, endSecSegAdj.termPt2):
                     endSecSeg.flipLine()
                  elif not (np.array_equal(endSecSeg.termPt1, endSecSegAdj.termPt1) or \
                            np.array_equal(endSecSeg.termPt1, endSecSegAdj.termPt2)):
                     print("ERROR - endSecSeg does NOT share any py with endSecSeg-1 - endSecSeg NOT CONTIGUOUS")

               # orient the ref seg so that it is in same direction of secSeg group
               secSegVect = endSecSeg.termPt2 - startSecSeg.termPt1
               secSegUnitVect = (secSegVect) / LA.norm(secSegVect)
               if np.dot(secSegUnitVect, refResultSeg.unitVect) < 0:
                  refResultSeg.flipLine()

               # check the start section of refResultSeg to see if it is completely overlapped by startSecSeg
               startPtProjParams = refResultSeg.lineProjInputToSelfWithInPerpSelfUnit(startSecSeg)
               endPtProjParams = refResultSeg.lineProjInputToSelfWithInPerpSelfUnit(endSecSeg, True)

               if not refResultSeg.lineLength:
                  refResultSeg.calcLineMetadata()

               # need to define the "hole" corresponding to the segment of refResultSeg that is removed
               # because of the redundant sec seg
               refSegHole = lineCls()

               # if the ref seg start pt is not completely overlapped within
               # start sec seg
               #
               # calculate the portion of the ref seg that is not covered
               #  by the start sec seg
               if startPtProjParams[0] > 0:
                  newStartLine = lineCls()
                  newStartLine.setStartPt(refResultSeg.termPt1)
                  newStartLine.setEndPt(refResultSeg.termPt1 + startPtProjParams[0] * refResultSeg.unitVect)
                  if not newStartLine.checkIfLineIsPoint():
                     newRefSegs.append(newStartLine)
                  # the hole is the end pt of the ref segment that is not redundant
                  # with the starting sec seg
                  refSegHole.setStartPt(refResultSeg.termPt1 + startPtProjParams[0] * refResultSeg.unitVect)
               else:
                  refSegHole.setStartPt(refResultSeg.termPt1)

               if endPtProjParams[0] > 0:
                  newEndLine = lineCls()
                  newEndLine.setStartPt(refResultSeg.termPt2 + endPtProjParams[0] * -refResultSeg.unitVect)
                  newEndLine.setEndPt(refResultSeg.termPt2)
                  if not newEndLine.checkIfLineIsPoint():
                     newRefSegs.append(newEndLine)
                  refSegHole.setEndPt(refResultSeg.termPt2 + endPtProjParams[0] * -refResultSeg.unitVect)
               else:
                  refSegHole.setEndPt(refResultSeg.termPt2)

               # add hole into map
               holeIdx = self.insertHoleIntoMaps(refSegHole)

            #NOTE - if the ref line is completely overlapped by the sec portions - it will be COMPLETELY
            #       removed because the newRefSegs list will not contain the original refLine
            refResultSegs = newRefSegs

         self.refSegIdxToCroppedLineSegs[refEntry[0]] = refResultSegs

   # API to look at particular holes (that match a certain criterion) and check
   # if it has a redundant existing contig seg
   # if that particular hole should be refilled (based on some certain condition)
   # and restored as a contig seg and the redundant existing seg should be removed
   # then this API will do that
   #  for example: if the hole is part of a longer web of contig segs than
   #  the contig seg web that the redundant seg is part of, then we should restore
   #  the hole and remove that existing redundant contig seg
   def refillParticularHolesWithExistingSegs(self, mapOfHolePtsToHoles):
      # first sort the contig segs in order by the length of the web it belongs to
      #   from longest to shortest web length

      # the sortedContigWebLen is a list of tuples with the first element (idx=0)
      #  as the contig seg idx (hash) and the second element (idx=1) as the web length
      #  that the contig seg has belongs to
      sortedContigWebLen = sorted(self.contigSegsMap.contigSegHashToWebLen.items(), \
                                  key=lambda x: x[1], reverse=True)

      for csHashWebLenPair in sortedContigWebLen:
         # check if the term pts of the contig seg is hole
         #  if it is:
         #    1) check if the hole has redundant seg
         #       if hole has remaining redundant seg -> remove the remaining
         #       redundant seg - need to remove the remaining seg in the
         #       gridCls's contigSegIdxToContigSeg map because that is where
         #       deletion will be performed
         #       restore the hole regardless

         # first need to make sure that the contig seg has not been deleted
         # in the grid
         workingCS = self.contigSegIdxToContigSeg.get(csHashWebLenPair[0])
         if workingCS:
            workingCSWebLen = csHashWebLenPair[1]
            for csPt in (workingCS.getStartPtAsTuple(), workingCS.getEndPtAsTuple()):
               for holeIdx in mapOfHolePtsToHoles.get(csPt, []):
                  # for each hole - check if there are redundant segs
                  #  in its proximity
                  proxLineClsObjIdxs = self.getProximityLineIdxs(holeIdx)
                  # for each prox lineCls object - check if the contig seg that the line
                  # belongs to is greater than the contig seg that the hole belongs to
                  #
                  #  need to make sure that the hole still exists as it may have already been
                  #  refilled in
                  for proxIdx in proxLineClsObjIdxs:
                     if self.lineSegIdxToLineSeg.get(proxIdx) and \
                        self.holeIdxToHole.get(holeIdx):
                        # given a line, get the contig seg and most importantly
                        # the web that the contig seg belongs to
                        csProxIdx = self.contigSegsMap.lineIdxToContigSegIdxAndPos.get(proxIdx)[0]
                        csProxWebLen = self.contigSegsMap.contigSegHashToWebLen.get(csProxIdx)
                        if workingCSWebLen >= csProxWebLen:
                           # check if the hole we are looking at and the line that is in proximity
                           # to it are considered redundant by checking the condition
                           # checkIf2LinesRedundant
                           if checkIf2LinesRedundant(self.lineSegIdxToLineSeg.get(proxIdx), \
                                                     self.holeIdxToHole.get(holeIdx), maxPerpDist=5.0):
                              # if the hole is attached to a contig seg that belongs to a longer
                              # web than the web that the contig seg that the redundant line
                              # is attached to - do the following
                              #
                              #  1) restore the hole as a line - thus need to
                              #     populate the hole back into the line seg map
                              #     and remove the hole from the hole map
                              if self.holeIdxToHole.get(holeIdx):
                                 self.lineSegIdxToLineSeg[holeIdx] = self.holeIdxToHole.get(holeIdx)
                                 self.removeHoleFromMaps(holeIdx)
                                 # delete the existing redundant line seg as represented
                                 # by proxIdx
                                 # delete from gridCls map and insert it as a hole
                                 newHole = self.removeLineFromMaps(proxIdx)
                                 self.insertHoleIntoMaps(newHole, proxIdx)

   # This API uses BCurves from contig segs to project segs to look for redundant
   # segs to remove
   def useBCurvesToProjectAndRmvRedundSegs(self):
      # loop thru the contig segs starting with the longest contig segs and
      # moving to shorter contig segs
      allProcessed = False
      csByLenOrder = self.getContigSegsSortedByLen()
      while not allProcessed:
         for contigSeg, contigSegLen in csByLenOrder:
            # now loop thru the contig seg curves starting from the longest curve within
            # the contig seg -> currently we only merge
            # TODO - put in condition where if the contigSeg is already processed - skip
            for combinedObj, COLen in contigSeg.getCombinedLinesAndCurvesSortedByLen().items():
               # for now only project bezier curves
               if type(combinedObj) == bezierCls:
                  # create projection lines of the bezier curve
                  # NOTE : thru empirical testing it has been determined that
                  # up to tLen = 0.2 gives good approximation of the projection of the bCurve
                  # Thus - projections will be limited to tProj <= 0.2. Thus, will use
                  # projection intervals to be 0.01
                  tLen = 0.2
                  projDelta_t = 0.01
                  #
                  # do both projection ends
                  projsInfo = combinedObj.calcBothProjsOfBCurve()
                  backAndForeProjPts = projsInfo[0]
                  for projPtsSet in backAndForeProjPts:
                     redundLineSegsToProj = []
                     redundHolesToProj = []
                     for i in range(len(projPtsSet)-1):
                        projLineSeg = lineCls(projPtsSet[i], projPtsSet[i+1])
                        print("Processing proj pts {}, {}".format(i, i+1))
                        adjLines = self.getProximityLineObjs(projLineSeg, 1)
                        adjHoles = self.getProximityHoleObjs(projLineSeg, 1)
                        # check for existing line segs that are redundant with the projection line
                        for adjLine in adjLines:
                           if checkIf2LinesRedundant(projLineSeg, adjLine) != None:
                              redundLineSegsToProj.append(adjLine)
                        # check if the projection line is in proximity with holes
                        for adjHole in adjHoles:
                           if checkIf2LinesRedundant(projLineSeg, adjHole) != None:
                              redundHolesToProj.append(adjHole)

                     # now that the redundant segs of the projection (backwards if i==0
                     # and forwards if i==1) are calculated - get the longest contiguous seg
                     # that if overlapped with the projection seg is the closest match
                     #  That longest seg will be shifted to the existing contig seg and curves will be recalculated
                     redundLinesStartPtToContigVerts = vertGraphTree.getStartPtToContigObjsMap(redundLineSegsToProj)
                     redundLinesContigVertsClusters = vertGraphTree.getSortedListOfContigClusters(redundLinesStartPtToContigVerts)

                     # get the longest contiguous hole segs as well - then check which of the longest contiguous segs
                     # has max overlap with the longest contiguous holes
                     redundHolesStartPtToContigVerts = vertGraphTree.getStartPtToContigObjsMap(redundHolesToProj)
                     redundHolesContigVertsClusters = vertGraphTree.getSortedListOfContigClusters(redundHolesStartPtToContigVerts)

                     # now that clusters of contig vertices of the existing segs that are redundant with the projection
                     # and the clusters of contig vertices of the holes that are redundant with the projection are retrieved,
                     #  - loop thru the clusters of contig verts of redund segs
                     #  - loop thru the cluster of verts of holes
                     #  - get the overlap between the list of verts of redund line and the hole which the current iter is pointing to
                     #    - the criteria for accepting the contig seg of redund segs is:
                     #
